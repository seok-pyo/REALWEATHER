# REALWEATHER

### REALWEATHER는 위치 기반으로 날씨 예보를 받아오는 서비스입니다. 원하는 지역의 날씨를 확인할 수 있습니다. 반응형 컴포넌트로 구현되어 모바일과 데스크탑에서 최적화된 UI를 제공합니다.

<br>

![](./images/preview.png)

- [배포 링크](https://realweather-weld.vercel.app/)
- [디자인 시안](https://www.figma.com/design/VaAxemBOOKLVBA1ld0EojD/RealWheather?node-id=0-1&t=Yaqg7R3y3sHxpAnn-1)

<br>

## 프로젝트 실행 방법

1. 레포지토리를 클론을 받습니다.
2. 2곳의 API를 사용합니다. 해당 API 키를 발급받습니다.

- [OpenWeatherAPI](https://openweathermap.org/api/one-call-3#start) : 날씨 정보 API - `OPENWEATHER_API_KEY` 변수 사용
- [Geocoder API 2.0](https://www.vworld.kr/dev/v4dv_geocoderguide2_s001.do) : 주소를 좌표로 변환하는 API - `GEO_API_KEY`변수 사용

3. 프로젝트 루트 디렉토리에 `.env.local` 파일을 생성하고, `OPENWEATHER_API_KEY`, `GEO_API_KEY` 변수명으로 각각의 API를 저장합니다.

```
OPENWEATHER_API_KEY=your_key_here
GEO_API_KEY=your_key_here
```

4. `npm install`을 실행합니다.
5. 루트 디렉토리에서 터미널에 `vercel dev`를 실행합니다.

<br>

## 구현한 기능에 대한 설명

### 1. 현재 위치 기반 날씨 정보

- 사용자의 현재 위치를 감지하여, 해당 위치의 날씨 정보를 보여줍니다. 현재 날씨 정보는 `날씨 정보` 위젯과 `시간별 날씨 정보` 위젯에 보여집니다.
- 유저가 위치를 공개하지 않을 시, `서울`의 현재 날씨 정보를 보여줍니다.
- `날씨 정보` 위젯에는 현재 날씨를 `아이콘, 온도, 현재날씨, 체감, 최저/최고, 일출/일몰`의 정보가 보여집니다.
- 지역명 앞에 있는 `즐겨찾기` 버튼을 통해 원하는 지역의 날씨 정보를 저장할 수 있습니다.
- `시간별 날씨 정보`는 지정한 위치의 시간대별 날씨 정보를 보여줍니다. 현재 시간 기준 48시간의 예보이며, 해당 정보들은 가로 스크롤을 통해 보여집니다.

### 2. 검색 기반 날씨 정보

- 대한민국의 지역명을 검색할 수 있습니다. 검색한 단어가 포함된 지역명이 검색창에 나오게 되며, 그 중 하나의 지역을 선택하게 되면 날씨 정보를 볼 수 있습니다.
- DB에 존재하지 않는 지역은 입력 시 `검색 결과가 없습니다`라는 메세지가 나오게 됩니다.
- API에 없는 날씨 정보인 경우 `해당 장소의 정보가 제공되지 않습니다`라는 메세지가 나오게 됩니다.
- API의 응답을 기다리는 동안 `날씨를 가져오고 있습니다`라는 메세지가 나오게 됩니다.
- 반응형 디자인이 적용되어, 모바일 화면에서는 `검색 아이콘`만 보이게 되며, 이 아이콘을 통해 검색을 할 수 있습니다.

### 3. 장소 '즐겨찾기' 기능

- 저장한 지역의 날씨 카드들을 한 눈에 볼 수 있습니다.
- 반응형 디자인이 적용되어, 모바일 화면으로 접속한 경우 헤더에 `MY` 버튼이 생성되고, 해당 버튼을 통해 `즐겨찾기` 위젯을 열고 닫을 수 있습니다.
- `날씨 카드`를 선택하게 되면, `현재의 날씨`와 `시간대별 날씨`의 정보가 선택한 지역의 정보로 업데이트 됩니다.
- `날씨 카드`의 지역명을 눌러 원하는 이름으로 수정할 수 있습니다.
- 최대로 저장 가능한 개수(6개)와 현재 저장된 카드의 개수가 보여집니다.

<br>

## 기술적 의사결정 및 이유

### API 선택 이유

- 초기 기획에서는 `기상청 단기예보 조회서비스`를 사용하여 API를 호출을 할 생각이었습니다.
  하지만, API의 데이터를 확인하니 `경도`와 `위도`를 API의 `x, y` 좌표로 변환이 필요하다는 것을 알게 되었습니다.
  좌표 변환 코드가 제공되었지만, 사용경험이 없고, 프로젝트의 기간을 고려하여 `경도`와 `위도`로 바로 호출을 할 수 있는 `openWeatherAPI`를 선택하게 되었습니다.
  또한, 날씨 아이콘이 제공된다는 점과 사용 명세서가 잘 작성되어 있는 것도 선택한 이유입니다.

### Vite 선택 이유

- SSR과 CSR 중 어떤 방식의 렌더링이 좋을 지 고민하였습니다. 이 중 CSR을 사용하는 `VITE`를 선택하였는데, 선택한 이유는 다음과 같습니다.
- 프로젝트의 규모가 크지 않고, 앱의 페이지가 `단일 페이지`라는 점.
- 현재 프로젝트는 `seo` 최적화가 필요하지 않다는 점.
- API 키를 보호하기 위한, 프록시 서버는 `vercel`의 `serverless function`으로 구현이 가능하다는 점.
- 과제를 구현하면서 SSR과 CSR의 실질적인 렌더링 속도 차이가 궁금해져, next.js로 포팅하여 `렌더링의 속도`의 차이를 확인해봐야 겠다는 생각을 하였습니다.

### FSD 아키텍쳐

- 프로젝트의 구조를 고려하여 FSD 슬라이스 중 `widgets`와 `entities` 슬라이스를 비중있게 사용하였습니다.
- 앱의 진입점과 쿼리 데이터를 주입하는 곳으로 `app` 슬라이스를 사용하였습니다.
- `pages` 슬라이스에서 위젯별로 작성된 컴포넌트를 조립하고, `전역상태`를 위치시켰습니다.
- 앱의 구조를 `widgets`의 컴포넌트로 설계하였고, `widgets` 안에서 데이터를 가져오는 컴포넌트를 `entities` 슬라이스에 위치시켰습니다.
- `entities`슬라이스에서 해당 컴포넌트가 필요한 API 요청을 합니다.
- `features` 슬라이스에는 유저가 실행할 수 있는 `검색기능`과 관련된 컴포넌트를 위치시켰습니다.
- `shared` 슬라이스에는 `zustand`로 만든 `store` 파일들을 모아두었습니다. 또한, 앱에서 사용되는 `assets` 파일들을 위치시켰습니다.

### 검색 기능

- json 파일을 로컬로 다운로드 받는 것이 고민이 되어 DB를 구축하는 것도 고려하였지만, 클라이언트에서 검색을 구현하는 것이 과제의 요구사항에 더 적합하다는 생각을 하여 json 방식으로 검색을 구현하였습니다.
- 검색 기능을 구현하기 위해, 제공된 json 파일을 `features` 슬라이스에 저장하여 `DB`로 사용하였습니다. `filter`와 `includes`를 사용하여 키워드를 찾아내는 커스텀 훅을 만들어 사용하였습니다.
- 입력된 단어들을 `tanstackQuery`를 통해 검색어를 캐싱하여 불필요한 API 호출을 방지하였습니다.
- 선택된 지역명은 좌표로 변환되어 `전역상태`로 저장하게 됩니다. 이 상태는 `zustand`로 구현하였으며, `현재 날씨 정보`, `시간별 날씨 정보`, 컴포넌트에서 구독하여 해당 값들의 변경을 감지하게 됩니다.

### TanStack Query

- 효율적인 API 호출과 편리하게 상태를 활용하기 위하여 `tanstack query`를 사용하였습니다.
- 검색 시 입력된 단어들은 쿼리가 캐싱되어 불필요한 API 호출을 방지할 수 있었습니다.

### Zustand

- 복잡한 상태들을 관리하고, `props drilling`을 방지하기 위해 `zustand`를 사용하였습니다.
- 반응형 디자인 구현에 필요한 `모바일 UI의 상태` 관리
- API 호출을 중복으로 하지 않기 위한 `좌표 데이터` 관리
- `현재 날씨` 위젯과 `즐겨찾기` 위젯에서 공유하는 상태 관리

### Vercel 선택 이유

- API Key의 보안을 위해서 프록시 서버를 두는 것이 나을 것 같다는 판단을 하였습니다.
- 프로젝트에 필요한 API 중 좌표 변환 API는 클라이언트에서 호출할 경우, 응답을 받지 못하는 것을 확인하였습니다. 따라서, 서버의 구축이 필요하였고 vercel의 serverless 함수를 이용하기로 하였습니다.
- 배포 또한 간편하여 `GitHub`와의 연동을 통해 편리하게 할 수 있다는 것도 선택하게 된 이유입니다.

<br>

## 트러블 슈팅

### API 타입 최적화

문제:

- OpenWeatherAPI에서 `current`, `daily`, `hourly` 데이터를 모두 받아오면서 타입 관리가 복잡해짐.
  해결:
- 제네릭을 사용하여, 공통 속성인 `temp`의 데이터를 통일

### 모바일 뷰 즐겨찾기 UX 구현

문제:

- 즐겨찾기 카드 클릭 시 모바일 뷰의 위젯을 닫는 기능이 필요
- 컴포넌트의 깊이가 깊어지면서 Propsdrilling 발생. MainPage - FavoriteList - WeatherFavorite(3단계)

해결:

- toggle 상태를 zustand 전역 상태로 변경하여, WeatherFavorite에서 직접 접근할 수 있도록 구현

### 검색 실패 시 UI 구현

문제:

- 좌표 변환 실패 또는 API 응답이 없음을 보여주는 UI 필요

해결:

- 검색 화면에서 데이터를 못 받아올 경우 메시지를 보여주기 위해, closeSearch를 useCallback으로 캐싱하고, useEffct 안에서 좌표값이 제대로 들어오지 않으면 닫히지 않도록 구현.
- handleClick 함수 안에서 setSelectAddress를 초기화. 이를 통해 '검색창' 혹은 '닫기' 버튼을 눌렀을 때 기존의 메시지를 지울 수 있도록 구현.
- 메시지를 보여주는 부분에서 삼항 연산자를 이용하여, 데이터의 상태에 따른 메시지를 보여줄 수 있도록 함.

### Vercel serverless 함수 요청 지역 변경

문제:

- `Geocoder API 2.0` 호출 시 정상적으로 vercel에 환경변수를 등록했으나, 응답 오류가 발생.

해결:

- `Geocoder API`는 `한국`에서 요청하지 않은 호출은 응답 오류를 발생시킴. vercel serverless 함수가 실행되는 지역(region)을 `icn1` 한국 지역으로 변경.

<br>

## 사용한 기술 스택

- Frontend: vite, react, tanstack-query, tail-wind, zustand
- Backend: vercel
- API: OpenWheatherMap, Geocoder API 2.0
- Design: Figma
